import Component from '@ember/component';

export default class FooBar extends Component {
  greeting = 'hello';

  args!: {
    optional?: string;
    required: string;
  }
};

type Element<T extends any[]> = T extends Array<infer Element> ? Element : never;

type HelperSignature<Positional extends [], Named extends {}> = [Positional, Named];


abstract class BaseHelper<Return> {
  abstract compute(...args: any[]): Return;
}

class Helper<Args extends Signature> extends BaseHelper<Element<Positional<Args, 0>>> {
  compute([collection]: [Args[0][0]]): Element<Args[0][0]> {
    return collection[0];
  }
}

type T = Helper<[[string[]], {}]>;
export type U = ReturnType<T['compute']>;

/*
// Sample component implementation
declare module 'my-component' {
  export type Signature = {
    a: string | boolean,
    b?: number
  };

  export default interface MyComponent<Args extends Signature> extends Signature {}
  export default class MyComponent<Args extends Signature> {
    affirmative: Args['a'] extends boolean ? true : 'yes';
  }
}

// Simplified examples how resolution works in a template like
// <MyComponent @a="hello" />
// <MyComponent @a={{true}} />
// <MyComponent @a={{5}} />
// <MyComponent />
declare module 'my-component/template' {
  import { resolveComponent } from 'registry';

  type invocationWithString = resolveComponent<'my-component', { a: string }>;
  type stringAffirmative = invocationWithString['affirmative']; // => 'yes'

  type invocationWithBoolean = resolveComponent<'my-component', { a: boolean }>;
  type booleanAffirmative = invocationWithBoolean['affirmative']; // => true;

  type invalidWrongType = resolveComponent<'my-component', { a: 5 }>;
  type invalidMissingProp = resolveComponent<'my-component', {}>;
}

// This would be autogenerated
declare module 'registry' {
  import MyComponent, { Signature as MyComponentSignature } from 'my-component';

  export interface SignatureRegistry {
    'my-component': MyComponentSignature,
  }

  export interface ComponentRegistry<T> {
    'my-component': T extends MyComponentSignature ? MyComponent<T> : never
  }

  export type resolveComponent<
    Name extends keyof ComponentRegistry<any> & keyof SignatureRegistry,
    Args extends SignatureRegistry[Name]
  > = ComponentRegistry<Args>[Name];
}
*/


/*

type HelperSignature<Positional extends any[], Named extends {}> = [Positional, Named];
type Positional<S extends HelperSignature<any, any>> = S extends [infer P, any] ? P : never;
type Named<S extends HelperSignature<any, any>> = S extends [any, infer N] ? N : never;

abstract class Helper<Return> {
  abstract compute(...args: any[]): Return;
}

type Signature = HelperSignature<[Promise<any>], {}>;
type Awaited<T> = T extends Promise<infer U> ? U : T;

class AwaitHelper<Args extends Signature> extends Helper<Awaited<Positional<Args>[0]> | undefined> {
    compute([promise]: Positional<Args>): Awaited<Positional<Args>[0]> | undefined {
        return;
    }
}

declare module 'registry' {
    export interface SignatureRegistry {
        'await': Signature;
    }

    export interface HelperRegistry<T> {
        'await': T extends Signature ? AwaitHelper<T> : never;
    }

    export type resolveHelper<
        K extends keyof SignatureRegistry & keyof HelperRegistry<any>,
        Args extends SignatureRegistry[K]
    > = HelperRegistry<Args>[K];
}

declare module 'xxx' {
    import { resolveHelper } from 'registry';

    type awaitHelper = resolveHelper<'await', [[Promise<string>], {}]>;
    type result = ReturnType<awaitHelper['compute']>;
}

*/
